<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="Python修炼：输入输出类型">




  <meta name="keywords" content="Python,">





  <link rel="alternate" href="/default" title="归">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://yoursite.com/2019/08/12/Python修炼：输入输出/">


<meta name="description" content="文件读写1.使用内置的open函数 2.open函数接受两个参数：文件名，打开方式f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;r&amp;#39;)  以读的方式打开test.txt文件，如果文件不存在则报错 默认编码是UTF-8，也可以使用命名关键字参数encodeing=’gbk’，指定编码 可以使用命名关键字参数errors=’ignore’，忽略其中的错误编码，否则会报错">
<meta name="keywords" content="Python">
<meta property="og:type" content="article">
<meta property="og:title" content="Python修炼：输入输出类型">
<meta property="og:url" content="http://yoursite.com/2019/08/12/Python修炼：输入输出/index.html">
<meta property="og:site_name" content="归">
<meta property="og:description" content="文件读写1.使用内置的open函数 2.open函数接受两个参数：文件名，打开方式f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;r&amp;#39;)  以读的方式打开test.txt文件，如果文件不存在则报错 默认编码是UTF-8，也可以使用命名关键字参数encodeing=’gbk’，指定编码 可以使用命名关键字参数errors=’ignore’，忽略其中的错误编码，否则会报错">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-08-13T05:00:59.164Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Python修炼：输入输出类型">
<meta name="twitter:description" content="文件读写1.使用内置的open函数 2.open函数接受两个参数：文件名，打开方式f = open(&amp;#39;test.txt&amp;#39;,&amp;#39;r&amp;#39;)  以读的方式打开test.txt文件，如果文件不存在则报错 默认编码是UTF-8，也可以使用命名关键字参数encodeing=’gbk’，指定编码 可以使用命名关键字参数errors=’ignore’，忽略其中的错误编码，否则会报错">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> Python修炼：输入输出类型 - 归 </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">归</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Python修炼：输入输出类型
        
      </h1>

      <time class="post-time">
          Aug 12 2019
      </time>
    </header>



    
            <div class="post-content">
            <h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><p>1.使用内置的open函数</p>
<p>2.open函数接受两个参数：文件名，打开方式<br><code>f = open(&#39;test.txt&#39;,&#39;r&#39;)</code></p>
<ul>
<li>以读的方式打开test.txt文件，如果文件不存在则报错</li>
<li>默认编码是UTF-8，也可以使用命名关键字参数encodeing=’gbk’，指定编码</li>
<li>可以使用命名关键字参数errors=’ignore’，忽略其中的错误编码，否则会报错</li>
</ul>
<p>3.文件对象的方法<br>①f.read()方法可以一次性读取文件的所有内容，并将结果用一个str对象表示</p>
<p>②f.readline()方法每次读取文件的一行，每调用一次返回一行</p>
<p>③f.readlines()方法一次性读取文件的所有内容，并将结果按行保存在一个list中</p>
<p>④f.write(‘hello world’)方法向文件写入一行内容</p>
<p>⑤f.close()方法关闭文件，文件使用后必须关闭以节约系统资源</p>
<ul>
<li>如果文件打开错误就不会关闭，为了保证无论出错与否都能正确关闭文件，可以使用with语句来帮我们自动调用close方法</li>
<li><code>with open(&#39;test.txt&#39;, &#39;r&#39;) as f</code></li>
</ul>
<p>⑥f.seek(offset,whence)方法移动文件指针，offset表示移动的字节数，正为向前，负为向后，whence是可选值，默认为0，表示相对于文件开头，1表示相对于当前位置，2表示相对于文件末尾</p>
<p>⑦f.tell()方法获取当前文件指针的位置</p>
<p>4.文件的操作模式</p>
<ul>
<li>‘r’：读</li>
<li>‘w’：写</li>
<li>‘a’：追加</li>
<li>‘r+’ == r+w（可读可写，文件若不存在就报错(IOError)）</li>
<li>‘w+’ == w+r（可读可写，文件若不存在就创建）</li>
<li>‘a+’ ==a+r（可追加可写，文件若不存在就创建）</li>
</ul>
<p>对应的，如果是二进制文件，就都加一个b就好啦：</p>
<ul>
<li>‘rb’　　‘wb’　　‘ab’　　‘rb+’　　‘wb+’　　‘ab+’<h2 id="StringIO和BytesIO"><a href="#StringIO和BytesIO" class="headerlink" title="StringIO和BytesIO"></a>StringIO和BytesIO</h2></li>
</ul>
<p>1.很多时候数据读写不一定是文件，也可以是内存中</p>
<h3 id="StringIO"><a href="#StringIO" class="headerlink" title="StringIO"></a>StringIO</h3><p>1.在内存中读写str</p>
<p>2.创建了StringIO对象之后，就可以向文件一样使用read()，write()方法了</p>
<p>3.常用方法：<br>①f.getvalue()获得f对象的值</p>
<p>②创建StringIO对象时，也可以使用一个字符串来初始化</p>
<ul>
<li>注意初始化之后对象指针还是在0位置的，也就是说此时如果使用f.write()方法，写入的内容会从起始处写而覆盖原来初始化的内容</li>
<li>使用了write()方法之后，指针移动相应的大小，所以write()方法是追加</li>
</ul>
<h3 id="BytesIO"><a href="#BytesIO" class="headerlink" title="BytesIO"></a>BytesIO</h3><p>1.BytesIO对象允许在内存中读写字节</p>
<h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><blockquote>
<p>os模块和os.path模块</p>
</blockquote>
<p>1.常用方法</p>
<ul>
<li><p>os.environ——当前操作系统中定义的环境变量</p>
</li>
<li><p>os.path.abspath(‘.’)——当前目录的绝对路径</p>
</li>
<li><p>os.path.join(‘c:/users/torcy’,’testdir’)——路径加上文件夹名，形成新的路径</p>
</li>
<li><p>os.mkdir(‘c:/users/torcy/testdir’)——创建一个目录</p>
</li>
<li><p>os.rmdir(‘c:/users/torcy/testdir’)——删除一个目录</p>
<blockquote>
<p>把两个路径合并成一个时，不能直接拼接字符串，而要通过os.path.join()函数，这样可以处理不同操作系统中的路径分隔符</p>
</blockquote>
</li>
<li><p>os.path.split()——把一个路径拆分为两部分，后一部分总是最后的目录或者文件名，返回一个tuple</p>
</li>
<li><p>os.path.splitext(’c:/users/torcy/test.txt‘)——直接得到文件的扩展名,返回(‘c:/users/torcy’,’,txt’)</p>
</li>
<li><p>os.rename(‘test.txt’,’test.py’)——对文件重命名</p>
</li>
<li><p>os.remove(‘test.txt’)——删除文件</p>
</li>
<li><p>os.listdir(‘c:/users/torcy/‘)——列出当前目录下的所有文件或文件夹</p>
</li>
<li><p>os.path.isdir(‘test’)——判断test是否是一个目录</p>
</li>
<li><p>os.path.isfile(‘test’)——判断test是否是一个文件</p>
</li>
</ul>
<p>2.一个小栗子<br>①实现dir命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i in [(time.strftime(&apos;%Y/%m/%d %H:%M:%S&apos;, time.localtime(os.path.getatime(name))), &apos;&lt;DIR&gt;&apos; if os.path.isdir(name) else &apos;     &apos;, str(os.path.getsize(name)).rjust(4), name)</span><br><span class="line">         for name in os.listdir(&apos;.&apos;)]:</span><br><span class="line">    print(str(i).strip(&apos;(&apos;).strip(&apos;)&apos;))</span><br></pre></td></tr></table></figure>

<p>②在当前目录及子目录下递归查找包含指定字符串的文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def find_file(s = &apos;&apos;, d = &apos;.&apos;):</span><br><span class="line">    items = os.listdir(d)</span><br><span class="line">    dirs,files = [], []</span><br><span class="line">    for i in items:</span><br><span class="line">        if os.path.isfile(i):</span><br><span class="line">            files.append(i)</span><br><span class="line">        elif os.path.isdir(i):</span><br><span class="line">            dirs.append(i)</span><br><span class="line">    for i in files:</span><br><span class="line">        if i.find(s) &gt;= 0:</span><br><span class="line">            print(i)</span><br><span class="line">    for di in dirs:</span><br><span class="line">        find_file(s,di)</span><br><span class="line">        </span><br><span class="line">print(find_file(&apos;test&apos;))</span><br></pre></td></tr></table></figure>

<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="pickle模块"><a href="#pickle模块" class="headerlink" title="pickle模块"></a>pickle模块</h3><p>1.变量从内存中编程可存储或传输数据的过程称之为<strong>序列化</strong>(pickling、serialization)</p>
<p>2.常用方法：<br><code>d = dict(name=&#39;torcy&#39;,age=20,score=88)</code></p>
<ul>
<li>pickle.dumps(d)——将对象序列化成bytes类型，然后就可以把bytes写入文件</li>
<li>pickle.dump(d,f)——将对象序列化成bytes类型，并写入f类文件对象</li>
<li>pickle.loads(b)——将序列化数据反序列化成一个对象，返回这个对象</li>
<li>pickle.load(f)——从一个类文件对象中读入数据，反序列化成一个对象，并返回<h3 id="json模块"><a href="#json模块" class="headerlink" title="json模块"></a>json模块</h3></li>
</ul>
<p>1.json不仅是标准格式，而且比XML更快</p>
<ul>
<li>json.dumps(d)——返回一个str</li>
<li>json.dump(d,f)——将序列化数据写入类文件对象</li>
<li>json.load(f)——从类文件对象中读入数据，反序列化成对象，并返回- json.loads(json_str)——将json字符串反序列化成对象，返回这个对象</li>
</ul>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/Python/">Python</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/08/12/DES算法学习/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">DES算法学习�库���</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2019/08/12/算法学习：动态规划/">
        <span class="next-text nav-default">算法学习：动态规划件开头添加两个字节的问题</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2019
    <span class="footer-author">Lollipop43.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
