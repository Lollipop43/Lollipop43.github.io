<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="JavaScript基础">




  <meta name="keywords" content="JavaScript,">





  <link rel="alternate" href="/default" title="归">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=1.1">



<link rel="canonical" href="http://yoursite.com/2019/08/11/JavaScript基础/">


<meta name="description" content="JavaScript基础知识整理">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript基础">
<meta property="og:url" content="http://yoursite.com/2019/08/11/JavaScript基础/index.html">
<meta property="og:site_name" content="归">
<meta property="og:description" content="JavaScript基础知识整理">
<meta property="og:locale" content="default">
<meta property="og:image" content="e:%5CWebNotes%5CJavaScript%5Cfigures%5C1565493718042.png">
<meta property="og:updated_time" content="2019-08-24T09:32:19.036Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript基础">
<meta name="twitter:description" content="JavaScript基础知识整理">
<meta name="twitter:image" content="e:%5CWebNotes%5CJavaScript%5Cfigures%5C1565493718042.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> JavaScript基础 - 归 </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">归</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          JavaScript基础
        
      </h1>

      <time class="post-time">
          Aug 11 2019
      </time>
    </header>



    
            <div class="post-content">
            <p>JavaScript基础知识整理</p>
<a id="more"></a>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>1.数据类型的检测</p>
<p>①typeof运算符</p>
<p>②instanceof运算符</p>
<p>③toString方法</p>
<h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><ol>
<li>特殊值<ul>
<li>Infinity</li>
<li>NaN不等于任何值<ul>
<li>[NaN].indexOf(NaN) === -1，该方法使用严格相等运算符</li>
</ul>
</li>
<li>+0和-0分别当作分母时，一个返回+Infinity另一个返回-Infinity</li>
</ul>
</li>
<li>JavaScript内部所有数字都是64位浮点数。所以1 === 1.0</li>
<li>全局方法：<ul>
<li>parseInt(string)<ul>
<li>接受字符串</li>
<li>允许添加第二个参数做进制转换，返回十进制数</li>
</ul>
</li>
<li>parseFloat(string)</li>
<li>isNaN()<ul>
<li>先将参数用Number转换，后判断</li>
</ul>
</li>
<li>isFinite()<ul>
<li>仅对Infinity，-Infinity，NaN，undefined返回false</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><ol>
<li>全局方法<ul>
<li>btoa(string)——base64编码</li>
<li>atob(string)——base64解码</li>
</ul>
</li>
</ol>
<h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><ul>
<li>{}内是表达式还是代码块？<ul>
<li>一律解释为代码块</li>
<li>放在()之中被认为是表达式</li>
</ul>
</li>
<li>删除对象的属性<ul>
<li>delete p</li>
<li>删除不存在的属性返回true</li>
<li>无法删除继承属性</li>
</ul>
</li>
<li>属性是否存在<ul>
<li>in运算符</li>
<li>不能识别自身和继承，使用hasOwnProperty()方法</li>
</ul>
</li>
<li>属性的遍历<ul>
<li><strong>for</strong>(var i <strong>in</strong> obj)</li>
<li>不可遍历属性会被跳过，如toString方法</li>
</ul>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>name属性</p>
<ul>
<li>获得函数的名字，当函数作为参数时可以得知传入的是什么函数</li>
</ul>
</li>
<li><p>length属性</p>
<ul>
<li>获得参数的个数</li>
</ul>
</li>
<li><p>toString方法</p>
</li>
<li><p>返回函数的源码，包括内部注释</p>
</li>
<li><p>原始值作为参数：按值传递；</p>
<p>复合值作为参数：按引用传递</p>
</li>
<li><p>函数体内部对象：arguments</p>
<ul>
<li>正常模式可重新在函数体内赋值，严格模式无效</li>
</ul>
</li>
<li><p>闭包：函数内部的函数</p>
<ul>
<li><p>在<strong>函数外部</strong>读取<strong>函数内部</strong>的变量</p>
</li>
<li><p>让内部变量始终保持在内存中：自增器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIncrementor</span>(<span class="params">start</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> inc = createIncrementor(<span class="number">5</span>);</span><br><span class="line">inc()<span class="comment">//5</span></span><br><span class="line">inc()<span class="comment">//6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>封装私有属性和私有方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _age;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setAge</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    _age = n;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = Person(<span class="string">'张三'</span>);</span><br><span class="line">p1.setAge(<span class="number">25</span>);</span><br><span class="line">p1.getAge() <span class="comment">// 25</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><ul>
<li>本质是一个对象，键名是整数，可以增加非整数键名的属性，但不会增加length值</li>
<li>length属性是一个动态值，值等于数组的最大整数键值加1</li>
<li>数组的某个位置是空位还是undefined在遍历时是不一样的情况：<ul>
<li>空位会被跳过，undefined不会</li>
</ul>
</li>
<li>类数组对象——所有键名都是正整数或0，而且具有length属性的对象<ul>
<li>根本特征就是length属性，而length值不是动态的，是一个属性，不会随其他属性的变化而变化</li>
</ul>
</li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><ul>
<li><p>对象转化成原始类型：</p>
<ul>
<li>首先调用对象的valueOf方法，若返回原始类型值，则结束，否则继续</li>
<li>否则再调用toString方法，若返回原始类型值，则结束，否则报错</li>
<li>可以通过重载这两个方法进行自定义原始类型值</li>
<li>特例：Date对象仅执行toString方法</li>
</ul>
</li>
<li><p>比较</p>
<ul>
<li><p>两个对象的比较</p>
<ul>
<li><p>===：比较的是地址</p>
</li>
<li><p>&gt; &lt;：比较的是值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1=&#123;&#125;,obj2=&#123;&#125;;</span><br><span class="line">obj1&gt;obj2;<span class="comment">//false</span></span><br><span class="line">obj1&lt;obj2;<span class="comment">//false</span></span><br><span class="line">obj1===obj2;<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>void运算符是执行一个表达式，不返回任何值，在超级链接中插入代码防止网页跳转</p>
</li>
</ul>
<h2 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h2><ul>
<li><p>静态方法：</p>
<ul>
<li>Object.keys(obj)——返回对象自身的属性组成的数组</li>
<li>Object.getOwnPropertyNames(obj)——返回对象自身的属性组成的数组，还包括不可枚举属性，如数组的length属性</li>
</ul>
</li>
<li><p>实例方法：</p>
<ul>
<li><code>Object.prototype.valueOf()</code>：返回当前对象对应的值。</li>
<li><code>Object.prototype.toString()</code>：返回当前对象对应的字符串形式。<ul>
<li>可以用来判断值的类型</li>
<li>Object.prototype.toString.call(obj)；防止该对象改写实例方法</li>
</ul>
</li>
<li><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式。</li>
<li><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。</li>
<li><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型。</li>
<li><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举。</li>
</ul>
</li>
<li><p>属性描述对象——每个属性都有一个内部的描述对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: <span class="number">123</span>,<span class="comment">//属性值</span></span><br><span class="line">  writable: <span class="literal">false</span>,<span class="comment">//属性值是否可写</span></span><br><span class="line">  enumerable: <span class="literal">true</span>,<span class="comment">//是否可遍历</span></span><br><span class="line">  configurable: <span class="literal">false</span>,<span class="comment">//该属性描述对象是否可写</span></span><br><span class="line">  <span class="keyword">get</span>: undefined,//getter函数</span><br><span class="line">  <span class="keyword">set</span>: undefined//setter函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Object.getOwnPropertyDescriptor(obj, ‘p’)——返回某个属性的描述对象</li>
<li>如果一个属性的<code>enumerable</code>为<code>false</code>，下面三个操作不会取到该属性<ul>
<li><code>for..in</code>循环</li>
<li><code>Object.keys</code>方法</li>
<li><code>JSON.stringify</code>方法<ul>
<li>可以通过设置某个属性为不可遍历，而在格式化输出时不显示某个属性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h2><ul>
<li>静态方法<ul>
<li>Array.isArray(arr)</li>
</ul>
</li>
<li>实例方法<ul>
<li>push，pop</li>
<li>shift，unshift</li>
<li>join</li>
<li>concat</li>
<li>reverse</li>
<li>slice</li>
<li>splice(start,end,addElement1,addElement2…)</li>
<li>sort(function (a,b) {} )</li>
<li>map(function (value, index, arrItself))——将每个值依次传入，将返回结果组成一个新的数组返回，不会跳过undefined和null但会跳过空位</li>
<li>forEach()——与map的区别在于不返回值</li>
<li>filter(function (value, index, arrItself) {} )——将符合条件的成员组成一个新数组返回</li>
<li>some(function (value, index, arrItself) {} )——存在成员的执行结果为true则返回true</li>
<li>every(function (value, index, arrItself) {} )——所有成员的执行结果为true则返回true</li>
<li>reduce(function (a, b) {} )——从左至右依次处理每个成员，最后返回一个值</li>
<li>reduceRight(function (a, b) {} )——从右至左依次处理每个成员，最后返回一个值</li>
<li>indexOf</li>
<li>lastIndexOf</li>
</ul>
</li>
</ul>
<h2 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h2><p>1.JavaScript能够表示的最小精度：Number.EPSILON</p>
<ul>
<li><p>实例方法</p>
<ul>
<li>toString(base)——将10进制数转换为其他进制<ul>
<li>parseInt——将其他进制转换为十进制数</li>
</ul>
</li>
</ul>
</li>
<li><p>自定义方法</p>
<blockquote>
<p>只能自定义在原型对象上，数值本身是无法自定义属性的</p>
</blockquote>
<ul>
<li><p>生成range数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.iterate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= <span class="keyword">this</span>; i++) &#123;</span><br><span class="line">    result.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="number">8</span>).iterate()</span><br><span class="line"><span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h2><ul>
<li>静态方法<ul>
<li>String.fromCharCode()——返回unicode码表示的字符串</li>
</ul>
</li>
<li>实例方法<ul>
<li>charAt()——和数组下标完全一致</li>
<li>charCodeAt()——返回指定位置字符的unicode码，是fromCharCode的逆操作</li>
<li>concat</li>
<li>slice</li>
<li>substring同上</li>
<li>substr同上</li>
<li>indexOf</li>
<li>lastIndexOf</li>
<li>trim——去除两端的空白字符</li>
<li>toLowerCase</li>
<li>toUpperCase</li>
<li>match()——检测是否存在子串或者符合正则表达式<ul>
<li>返回一个数组</li>
<li>这个数组具有index和input属性，分别表示第一个匹配的位置和原始字符串</li>
</ul>
</li>
<li>search同match，返回匹配的第一个位置</li>
<li>replace(‘’, ‘’)</li>
<li>replace(‘’, function (match) {} )——将每一个匹配的子串替换为函数的返回值</li>
<li>split</li>
</ul>
</li>
</ul>
<h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><ul>
<li>静态方法<ul>
<li><code>Math.abs()</code>：绝对值</li>
<li><code>Math.ceil()</code>：向上取整</li>
<li><code>Math.floor()</code>：向下取整</li>
<li><code>Math.max()</code>：最大值</li>
<li><code>Math.min()</code>：最小值</li>
<li><code>Math.pow()</code>：指数运算</li>
<li><code>Math.sqrt()</code>：平方根</li>
<li><code>Math.log()</code>：自然对数</li>
<li><code>Math.exp()</code>：<code>e</code>的指数</li>
<li><code>Math.round()</code>：四舍五入</li>
<li><code>Math.random()</code>：随机数</li>
<li><code>Math.trunc()</code>: 用于去除一个的小数部分</li>
<li><code>Math.sign()</code>: 判断一个数到底是正数，负数，还是零</li>
<li><code>Math.cbrt()</code>: 计算一个数的立方根</li>
</ul>
</li>
</ul>
<h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><ul>
<li>静态方法<ul>
<li>Date.now()——当前事件距离时间零点的毫秒数</li>
</ul>
</li>
<li>实例方法<ul>
<li>valueOf——实例对象距离时间零点的毫秒数</li>
<li>getTime同上</li>
<li>toLocaleString</li>
<li>toLocaleDateString</li>
<li>getDate——每月的几号</li>
<li>getDay——星期几</li>
<li>getFullYear</li>
<li>getMonth</li>
<li>getHours</li>
<li>getMilliseconds</li>
<li>getMinutes</li>
<li>getSeconds</li>
</ul>
</li>
</ul>
<h2 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h2><hr>
<ul>
<li>实例方法<ul>
<li>test——返回布尔值</li>
<li>exec——返回匹配成功的子串组成的数组，否则null<ul>
<li>还包含index属性和input属性</li>
<li>正则表达式加上g修饰符，可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始</li>
<li>正则表达式遇到换行符就会停止匹配</li>
<li>\1  \2   \3分别表示匹配到的组</li>
</ul>
</li>
</ul>
</li>
<li>实例属性<ul>
<li>/…/.source——正则表达式的正文</li>
<li>/…/.flags——已经设置的修饰符</li>
</ul>
</li>
</ul>
<h2 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h2><ul>
<li>JSON.stringify<ul>
<li>将其他类型的值转换为JSON格式，或过滤掉不符合的数据类型（日期，函数）</li>
<li>正则对象被转换为空对象</li>
<li>日期函数被转换为null</li>
<li>可以给对象自定义toJSON方法，使用该规则进行转换</li>
</ul>
</li>
<li>JSON.parse</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>1.构造函数就是一个普通的函数</p>
<ul>
<li>内部使用this关键字，表示<strong>将要生成的对象实例</strong></li>
<li>生成对象时必须使用new</li>
<li>严格模式下不使用new会报错</li>
</ul>
<p>2.new命令的4个步骤</p>
<ul>
<li>创建空对象，作为将要返回的对象实例</li>
<li>将空对象的原型指向构造函数的prototype属性</li>
<li>将空对象赋值给函数内部的this</li>
<li>开始执行构造函数</li>
</ul>
<p>3.构造函数中的return语句若返回的不是对象将被忽略，否则自动返回this对象</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>1.this是属性或方法当前所在的对象，this指向是可变的</p>
<p>2.绑定this</p>
<p>①函数实例call方法，可以指定函数内部this的指向</p>
<ul>
<li><p>f.call(add, 1,2,3)——后面可以跟参数</p>
</li>
<li><p><strong>调用对象的原生方法而不是被重载的</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖掉继承的 hasOwnProperty 方法</span></span><br><span class="line">obj.hasOwnProperty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, <span class="string">'toString'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>Object.prototype.hasOwnProperty方法是原生的，将该方法放在obj对象环境上调用</p>
</li>
</ul>
<p>②函数实例方法apply作用和call类似，不过可以接受数组作为函数执行参数</p>
<ul>
<li><p>找到数组的最大元素</p>
<p>Math.max.apply(null, arr)</p>
</li>
<li><p>将数组的空元素变为undefined，防止遍历时跳过</p>
<p>Array.apply(null,[‘a’, , ‘b’])——利用Array构造函数</p>
</li>
<li><p>将类数组对象转换为数组</p>
<p>Array.prototype.slice.apply({0:1, length:1})——被处理的对象必须具有length属性和数字键</p>
</li>
</ul>
<p>③apply和call方法不仅会绑定this，还会立即执行函数，这给回调函数增加了困难</p>
<p>​    函数实例的bind方法将函数体内的this绑定到某个对象，然后返回一个新函数</p>
<ul>
<li>每运行一次就返回一个新函数，所以绑定之后应该赋值到一个新变量上，防止重复生成</li>
<li>使用回调函数时就需要绑定this，否则容易出错</li>
</ul>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><blockquote>
<p>问题：构造函数为实例对象定义属性，同一个构造函数的多个实例之间无法共享属性</p>
</blockquote>
<p>1.<strong>每个函数都有一个prototype属性，指向一个对象</strong></p>
<ul>
<li>构造函数生成实例的时候，<strong>该对象会自动成为实例对象的原型</strong></li>
<li>实例对象可以看作原型对象的子对象</li>
</ul>
<p>2.原型链</p>
<ul>
<li>所有对象都继承了Object.prototype的属性，Object.prototype对象的原型是null</li>
<li>prototype对象有一个constructor属性，指向prototype对象所在的构造函数<ul>
<li>可以得知某个实例对象到底是哪一个构造函数产生的constructor.name</li>
<li>可以从一个实例对象新建另一个实例</li>
</ul>
</li>
</ul>
<p>3.<code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v <span class="keyword">instanceof</span> Vehicle</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure>

<p>4.instanceof运算符可以检测一个对象是否是null</p>
<ul>
<li>只能用于对象，不能用于原始类型的值</li>
</ul>
<h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><p>第一步：在子类的构造函数中调用父类的构造函数<code>Super.call(this)</code></p>
<p>第二步：让子类的原型指向父类的原型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.prototype.method = <span class="string">'...'</span>;</span><br></pre></td></tr></table></figure>

<p>上面是子类整体继承父类，有时只需要单个方法的继承，可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classB.prototype.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	classA.prototype.method.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Object对象的相关方法"><a href="#Object对象的相关方法" class="headerlink" title="Object对象的相关方法"></a>Object对象的相关方法</h2><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>①<code>Object.getPrototypeOf（a）</code>——返回参数对象的原型</p>
<p>②<code>Object.setPrototypeOf（a，b）</code>——设置参数对象的原型</p>
<ul>
<li>new命令可以使用setPrototypeOf方法模拟</li>
</ul>
<p>③<code>B = Object.create(A)</code>——以A对象为原型创建B对象</p>
<ul>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.create !== <span class="string">'function'</span>)&#123;</span><br><span class="line">    <span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">        F.prototype = obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Object.create(null)</code>生成的对象不继承任何对象方法</p>
</li>
</ul>
<p>④<code>Object.getOwnPropertyNames()</code></p>
<h3 id="实例对象方法"><a href="#实例对象方法" class="headerlink" title="实例对象方法"></a>实例对象方法</h3><p>①<code>Object.prototype.isPrototypeOf()</code>——检测一个对象是否是另一个对象的原型</p>
<p>②<code>Object.prototype.__proto__</code>——实例对象的一个属性，返回对象的原型</p>
<ul>
<li>获取实例对象的原型，有三种方法<ul>
<li>obj.__proto__——只有浏览器才需要部署</li>
<li>obj.constructor.prototype——更改原型时有可能忘记更改constructor</li>
<li>Object.getPrototypeOf(obj)——最安全可靠</li>
</ul>
</li>
</ul>
<p>③Object.prototype.hasOwnProperty(‘…’)——唯一一个处理对象属性时，不会遍历原型链的方法</p>
<p><img src="E:%5CWebNotes%5CJavaScript%5Cfigures%5C1565493718042.png" alt="1565493718042"></p>

            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/JavaScript/">JavaScript</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/08/12/8086汇编读书笔记/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">8086汇编读书笔记</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    
    
      <a class="next" href="/2019/08/11/JavaScript高级/">
        <span class="next-text nav-default">JavaScript高级</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
        2014 -
    
    2019
    <span class="footer-author">Lollipop43.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a> and <a class="theme-link" href="https://github.com/frostfan/hexo-theme-polarbear">Polar Bear</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
